---
title: "Dynamic Model Fit"
runtime: shiny
output: 
  flexdashboard::flex_dashboard:
    orientation: columns
    source_code: embed
    theme: cosmo
always_allow_html: yes
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)


library(rmarkdown)
library(lavaan)
library(tidyverse)
library(simstandard)
library(shiny)
library(shinythemes)
library(flexdashboard)
library(knitr)
library(tools)
library(patchwork)
library(shinybusy)
library(purrr)
library(stringr)
#library(shinycssloaders)

#List aesthetics first
```

<style type="text/css">

body {
  font-family: Palatino;
}

.shiny-output-error-validation {
        color: #ff0000;
      }

</style>

<!-- Search Engine Optimization -->
<html>
<head>
<title>Dynamic Fit Index Cutoffs for CFA Models</title>

<meta name="description" content="Derive dynamic fit index cutoffs that are adaptively tailored to the specific factor model and data being evaluated."/>
</head>
</html>

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-167733193-2"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-167733193-2');
</script>

```{r design}
fluidPage(theme = shinytheme("slate"),
          shinybusy::add_busy_bar(color = "#BECEE4"))

library(shiny)
?fluidPage()

options(shiny.sanitize.errors = FALSE)
```

Sidebar {.sidebar}
=====================================

This app uses Monte Carlo simulations to generate dynamic fit index cutoff values for multi-factor models.

\  

```{r inputs}
numericInput("sampsize", "Input Sample Size", value=NULL)

fileInput("model_syntax", "Input Model Statement",
          placeholder = ".txt file",
          accept = c("text",
                     ".txt",
                     "txt"))

helpText("This may take a few minutes.
         Please only press submit once.")

actionButton("go", "Submit")
```

```{r rename}
#Name inputs
n <- eventReactive(input$go,{input$sampsize})
model <- eventReactive(input$go,{input$model_syntax})
```

```{r trycatch}
##Catching Errors

#Returns 1 if there is lavaan is unable to lavaanify a statement
modelerror <- function(model){
  
  #read in the model
  Mod <- utils::read.delim(model()$datapath, header = FALSE)   
  Mod_C <- base::as.character(Mod$V1)
  
  tryCatch({
    lavaan::lavaanify(Mod_C)
  },
  error = function(e){
    return(1)
  })
}

#Counts number of NAs in the ustart column from lavaanify.  I'm a little worried about this one, but the goal is to catch anyone who omits a plus sign.  Returns the number of rows with an NA, so we want a value of 0 for no errors.
missing_plus <- function(model){
  
  #read in the model
  Mod <- utils::read.delim(model()$datapath, header = FALSE)   
  Mod_C <- base::as.character(Mod$V1)

  #prep the model
  lav_file <- lavaan::lavaanify(Mod_C, fixed.x=FALSE) %>%
    dplyr::filter(.data$lhs != .data$rhs)

  #record number of NA values
  na_val <- lav_file %>% 
  filter(is.na(lav_file$ustart))
  
  #count NAs
  na_val_count <- nrow(na_val)
  
  return(na_val_count)

}
```

```{r number_factor}
#### Function for Number of Factors ####

number_factor <- function(model){
  
  #read in the model
  Mod <- utils::read.delim(model()$datapath, header = FALSE)   
  Mod_C <- base::as.character(Mod$V1)

  #prep the model
  lav_file <- lavaan::lavaanify(Mod_C, fixed.x=FALSE) %>%   
    dplyr::filter(.data$lhs != .data$rhs)                  
  
  #isolate factors
  factors <- lav_file %>%                    
    dplyr::filter(op=="=~") %>%            
    dplyr::select(lhs) %>%                 
    base::unique()                   
  
  #identify number of factors in model
  num_factors <- base::nrow(factors)      
  
  return(num_factors)
}
```

```{r unstandardized}
#Did they enter unstandardized loadings?  Aka, do they have any loadings = 1?
unstandardized <- function(model){
  Mod <- utils::read.delim(model()$datapath, header = FALSE)   
  Mod_C <- base::as.character(Mod$V1)             
  
  lav_file <- lavaan::lavaanify(Mod_C, fixed.x=FALSE) %>%  
    dplyr::filter(.data$lhs != .data$rhs)                  
  
  one_plus <- lav_file %>% 
    dplyr::filter(ustart >= 1 | ustart <= -1) %>% 
    base::nrow()
  
  return(one_plus)
}

```

```{r cleanmodel}
#### Function to create model statement without numbers from user model (for input) ####

cleanmodel <- function(model){
  
  #read in the model
  Mod <- utils::read.delim(model()$datapath, header = FALSE)   
  Mod_C <- base::as.character(Mod$V1)
  
  clean <- Mod_C %>%
    lavaan::lavaanify(fixed.x = FALSE) %>%
    dplyr::filter(.data$lhs != .data$rhs) %>%
    dplyr::group_by(.data$lhs, .data$op) %>%
    dplyr::summarise(rhs = paste(.data$rhs, collapse = " + ")) %>%
    dplyr::arrange(dplyr::desc(.data$op)) %>%
    tidyr::unite("l", .data$lhs, .data$op, .data$rhs, sep = " ") %>%
    dplyr::pull(.data$l)
  
  return(clean)
  
}
```

```{r}
defre <- function(model,n){
  
  #Get clean model equation
  mod <- cleanmodel(model()$datapath)
  
  #Get parameters for true dgm
  Mod <- utils::read.delim(model()$datapath, header = FALSE)   
  Mod_C <- base::as.character(Mod$V1) 
  
  #Rename 
  true_dgm <- Mod_C
  
  #Run one simulation
  dat <- simstandard::sim_standardized(true_dgm,n=n(),latent=FALSE,errors=FALSE)
  fit <- lavaan::cfa(model=mod,data=dat,std.lv=TRUE)
  
  #Number of freely estimated paths
  paths <- base::max(lavaan::parTable(fit)$free)
  
  #Number of unique values in input matrix
  parms <- base::nrow(lavaan::lavInspect(fit,"std.lv")$theta)
  tot.parms <- (parms*(1+parms))/2
  
  #Subtract
  return(tot.parms-paths)
}
```

```{r multi_factor_num}
### Function to see which items are available ###

multi_factor_num <- function(model){
  
  Mod <- utils::read.delim(model()$datapath, header = FALSE)   
  Mod_C <- base::as.character(Mod$V1)   
  
  #Lavaanify it - have lavaan tell us the parameters
  lav_file <- lavaan::lavaanify(Mod_C, fixed.x=FALSE) %>%
    dplyr::filter(.data$lhs != .data$rhs)
  
  #identify all factor names
  factors <- lav_file %>%
    dplyr::filter(op=="=~") %>%
    dplyr::select(lhs) %>%
    base::unique()
  
  #Identify number of items per factor
  num_items <- lav_file %>%
    dplyr::filter(op=="=~") %>%
    dplyr::group_by(lhs) %>%
    dplyr::count() %>%
    dplyr::ungroup() %>%
    base::as.data.frame() %>%
    `colnames<-`(c("lhs","Original"))
  
  #Identify any items that already have an error covariance
  items_covariance <- factors %>%
    dplyr::mutate(type="Factor") %>%
    dplyr::full_join(lav_file, by = "lhs") %>%
    dplyr::select(-type,type) %>%
    dplyr::select(lhs,op,rhs,type) %>%
    dplyr::filter(op=="=~" | is.na(type)) %>%
    dplyr::filter(is.na(type)) %>%
    dplyr::select(-type) %>%
    tidyr::pivot_longer(-op,names_to = "test", values_to = "rhs") %>%
    dplyr::select(-op,-test) %>%
    dplyr::mutate(lhs=NA,op=NA,ustart=NA)
  
  #Isolate the items that do not already have an error covariance or cross-loading
  solo_items <- lav_file %>%
    dplyr::select(lhs,op,rhs,ustart) %>%
    base::rbind(items_covariance) %>%
    dplyr::filter(op=="=~"|is.na(op)) %>%
    dplyr::group_by(rhs) %>%
    dplyr::add_tally() %>%
    dplyr::filter(n==1) %>%
    dplyr::ungroup()
  
  #Count number of items remaining per factor
  remaining <- solo_items %>%
    dplyr::group_by(lhs) %>%
    dplyr::select(-n) %>%
    dplyr::count() %>%
    dplyr::ungroup() %>%
    dplyr::full_join(num_items,by="lhs") %>% 
    base::as.data.frame() %>%
    `colnames<-`(c("lhs","Remaining","Original"))
  
  #Add in factor loadings, group by number of items per factor (>2 or 2)
  #And sort factor loadings magnitude within group 
  itemoptions <- solo_items %>%  
    dplyr::full_join(remaining,by="lhs") %>% 
    dplyr::mutate(priority=ifelse(Original>2 & Remaining !="NA","Three","Two")) %>% 
    dplyr::group_by(priority) %>% 
    dplyr::arrange(abs(ustart), .by_group=TRUE) %>% 
    dplyr::ungroup() %>% 
    dplyr::select(lhs,rhs,ustart,priority) %>% 
    base::as.data.frame() %>%
    dplyr::as_tibble() %>%
    `colnames<-`(c("lhs","Item","Loading","Priority"))
  
  return(itemoptions)
}
```


```{r multi_factor}
#### Function to identify available items and loading magnitude ####

multi_factor <- function(model){
  
  #read in the model
  Mod <- utils::read.delim(model()$datapath, header = FALSE)   
  Mod_C <- base::as.character(Mod$V1)
  
  #Lavaanify it - have lavaan tell us the parameters
  lav_file <- lavaan::lavaanify(Mod_C, fixed.x=FALSE) %>%
    dplyr::filter(.data$lhs != .data$rhs)
  
  #read in number of factors
  num_fact <- number_factor(model()$datapath)
  
  #read in viable items from each factor
  itemoptions <- multi_factor_num(model()$datapath)
  
  #select lowest loading from each factor, in order of magnitude
  crosses <- itemoptions %>% 
    dplyr::group_by(lhs) %>% 
    dplyr::slice_min(base::abs(Loading)) %>% 
    dplyr::ungroup() %>% 
    dplyr::arrange(Priority,base::abs(Loading)) %>% 
    dplyr::slice(1:(num_fact-1))
  
  #identify all factor names (again)
  factors <- lav_file %>%
    dplyr::filter(op=="=~") %>%
    dplyr::select(lhs) %>%
    base::unique()
  
  #Compute Coefficient H for each factor
  Coef_H <- lavaan::lavaanify(Mod_C, fixed.x = FALSE) %>%
    dplyr::filter(lhs != rhs) %>%
    dplyr::filter(op == "=~") %>%
    dplyr::mutate(L_Sq=ustart^2) %>%
    dplyr::mutate(E_Var=1-L_Sq) %>%
    dplyr::mutate(Div=L_Sq/E_Var) %>%
    dplyr::group_by(lhs) %>%
    dplyr::summarise(Sum=sum(Div)) %>%
    dplyr::mutate(H=((1+(Sum^-1))^-1)) %>%
    dplyr::select(-Sum) %>%
    dplyr::arrange(-H) %>%
    `colnames<-`(c("rhs","H"))

  #isolate factors and factor correlations
  factcor1 <- factors %>%
    dplyr::mutate(type="Factor") %>%
    dplyr::full_join(lav_file, by = "lhs") %>%
    dplyr::mutate(type=recode(type, .missing ="Error Correlation")) %>%
    dplyr::select(lhs,op,rhs,ustart,type) %>%
    dplyr::filter(op=="~~" & type=="Factor")

  #flip in reverse so we get a list of all factors in one column
  factcor2 <- factors %>%
    dplyr::mutate(type="Factor") %>%
    dplyr::full_join(lav_file, by = "lhs") %>%
    dplyr::select(lhs,op,rhs,ustart,type) %>%
    dplyr::filter(op=="~~" & type=="Factor") %>%
    `colnames<-`(c("rhs","op","lhs","ustart","type")) %>%
    dplyr::select(lhs,op,rhs,ustart,type)
  
  #Isolate items
  dup1 <- factcor1 %>%
    dplyr::full_join(factcor2, by = c("lhs", "op", "rhs", "ustart", "type")) %>% 
    dplyr::full_join(crosses,by="lhs") %>% 
    dplyr::full_join(Coef_H,by="rhs") %>% 
    dplyr::filter(Item != "NA") %>% 
    dplyr::arrange(abs(Loading))
  
  #Run twice for cleaning later
  dup2 <- dup1
  
  #Manipulate to create model statement
  #Need to add factor correlation statement where lowest comes first
  #So that we can remove from contention once a factor correlation is added
  setup <- base::rbind(dup1,dup2) %>%  
    dplyr::mutate(lhs_1=lhs,
           rhs_1=rhs,
           f_min=base::pmin(lhs_1,rhs_1),
           f_max=base::pmax(lhs_1,rhs_1)) %>% 
    tidyr::unite(facts,c("f_min","f_max")) %>% 
    dplyr::select(-lhs_1,-rhs_1) %>% 
    dplyr::distinct(lhs,op,rhs,ustart,type,Item,Loading,Priority,H,.keep_all = TRUE)
  
  
  #Rename for iteration
  setup_copy <- setup
  
  #Create empty dataframe
  cleaned <- base::data.frame(base::matrix(nrow=0,ncol=10)) %>% 
    `colnames<-`(names(setup)) %>% 
    dplyr::mutate_if(is.logical, as.character)
  
  #Cycle through to grab F-1 misspecifications
  #Select the highest H for first item I (for crossloading)
  #Use anti_join to remove that factor correlation from the list for the next item
  for (i in unique(setup_copy$Item)){
    cleaned[i,] <- setup_copy %>% 
      dplyr::filter(Item==i) %>% 
      dplyr::slice_max(H)
    setup_copy <- dplyr::anti_join(setup_copy,cleaned,by="facts")
  }
  
  #Prep dtaframe for model statement
  modinfo <- cleaned %>% 
    dplyr::mutate(operator="=~",
           H=base::as.numeric(H),
           Loading=base::as.numeric(Loading),
           ustart=base::as.numeric(ustart)) %>% 
    dplyr::arrange(Priority,Loading,-H) 
  
  #Compute maximum allowable cross loading value
  Cross_Loading <- modinfo %>% 
    dplyr::mutate(F1=ustart,
           F1_Sq=F1^2,
           L1=Loading,
           L1_Sq=L1^2,
           E=1-L1_Sq) %>% 
    dplyr::mutate(MaxAllow=((base::sqrt(((L1_Sq*F1_Sq)+E))-(abs(L1*F1)))*.95),
           MaxAllow2=base::round(MaxAllow,digits=4),
           Final_Loading=base::pmin(abs(Loading),abs(MaxAllow2)),
           times="*") %>% 
    dplyr::select(rhs,operator,Final_Loading,times,Item) %>% 
    tidyr::unite("V1",sep=" ")
           
  #return value to append to model statement
  return(Cross_Loading)
}
```

```{r misspecified_dgm}
#### Function to create Misspecified DGM given the number of factors ####

Misspecified_DGM_Multi <- function(model){

  mod <- multi_factor(model()$datapath)
  
  #Get parameters for true dgm
  Mods <- utils::read.delim(model()$datapath, header = FALSE)   
  #Mod_C <- base::as.character(Mods$V1) 
  
  #multi_mod <- lapply(mod, function(x) rbind(Mods,mod[seq(x), ,drop = FALSE]) %>%
  #                      data.frame() %>% 
  #                      pull(V1))
  
  #This made you miserable. Shiny was struggling with \n at the end of strings here, for some reason.
  
  #Create a list for every row in the mod object (misspecifications)
  #For each element, bind the misspecification to the OG model statement sequentially
  #Turn it into a dataframe and extract
  multi_mod <- lapply(seq(nrow(mod)), function(x) rbind(Mods,mod[seq(x), ,drop = FALSE]) %>%
                        base::data.frame() %>% 
                        dplyr::pull(V1))
  
  return(multi_mod)
  
}

```

```{r misspec_mod_fit}
### Simulate fit indices for misspecified model for all levels ###

misspecified_model_fit <- function(model,n){

  #Get clean model equation
  mod <- cleanmodel(model()$datapath)

  #Get parameters for misspecified dgm (this is a list)
  misspec_dgm <- Misspecified_DGM_Multi(model()$datapath)

  #Use max sample size of 2000
  n <- min(n(),2000)
  
  #Set seed
  set.seed(269854)
  
  #Simulate one large dataset for each misspecification (use map to apply across each
  #element (set of misspecifications) in the list)
  all_data_misspec <- purrr::map(misspec_dgm,~simstandard::sim_standardized(m=.,n=n*500,
                                                        latent=FALSE,errors=FALSE))
  
  #Create indicator to split into 500 datasets for 500 reps
  rep_id_misspec <- rep(1:500,n)
  
  #Combine indicator with dataset for each element in list
  dat_rep_misspec <- purrr::map(all_data_misspec,~cbind(.,rep_id_misspec))
  
  #Group and list
  misspec_data <- purrr::map(dat_rep_misspec,~group_by(.,rep_id_misspec) %>% 
                        tidyr::nest())
  
  #Grab data level of the list
  data <- purrr::map(misspec_data,2)
  
  #Run 500 cfa for each element in the list
  misspec_cfa <- purrr::map(data, function(x) purrr::map(x, function(y) lavaan::cfa(model = mod, data=y, std.lv=TRUE)))
  
  #Extract fit stats from each rep (list) into a data frame and clean using nested lapply
  #map_dfr returns data frame instead of list
  #for each misspecification level (in the list), access the lavaan objects (x)
  #and extract the fit stats (y) - and return as a df
  misspec_fit_sum <- purrr::map(misspec_cfa, function(x) purrr::map_dfr(x, function(y) lavaan::fitMeasures(y, c("srmr","rmsea","cfi"))) %>% 
                           `colnames<-`(c("SRMR_M","RMSEA_M","CFI_M")) %>%
                           dplyr::mutate(Type_M="Misspecified"))

  set.seed(NULL)

  return(misspec_fit_sum)

}

```

```{r true_dgm}
#### Function to create True DGM (aka, just the model the user read in) ####
true_model_fit <- function(model,n){
  
  #Can make this faster by only doing it once
  #Would need to change table. Not sure what would happen to plot.

  #Get clean model equation
  mod <- cleanmodel(model()$datapath)
  
  #Get parameters for true dgm
  Mods <- utils::read.delim(model()$datapath, header = FALSE)   
  Mod_C <- base::as.character(Mods$V1) 
  
  #Rename
  true_dgm <- Mod_C

  #Use max sample size of 10000
  n <- base::min(n(),2000)
  
  #Set Seed
  set.seed(267326)
  
  #Simulate one large dataset  
  all_data_true <- simstandard::sim_standardized(m=true_dgm,n = n*500,
                                       latent = FALSE,
                                       errors = FALSE)
  
  #Create indicator to split into 500 datasets for 500 reps
  rep_id_true <- base::rep(1:500,n)
  
  #Combine indicator with dataset
  dat_rep_true <- base::cbind(all_data_true,rep_id_true)
  
  #Group and list
  true_data <- dat_rep_true %>% 
    dplyr::group_by(rep_id_true) %>% 
    tidyr::nest() %>% 
    base::as.list()
  
  #Run 500 cfa
  true_cfa <- purrr::map(true_data$data,~lavaan::cfa(model = mod, data=., std.lv=TRUE))
  
  #Extract fit stats from each rep (list) into a data frame and clean
  true_fit_sum <- purrr::map_dfr(true_cfa,~lavaan::fitMeasures(., c("srmr","rmsea","cfi"))) %>% 
    `colnames<-`(c("SRMR_T","RMSEA_T","CFI_T")) %>%
    dplyr::mutate(Type_T="True")

  set.seed(NULL)

  return(true_fit_sum)

}
```

```{r multi_df}
#### Function to combine both model fit stats for all levels into one dataframe ####

multi_df <- eventReactive(input$go,{
  
  #Use max sample size of 2000
  n <- min(n(),2000)

  #Get fit stats for misspecified model
  misspec_fit <- misspecified_model_fit(model()$datapath,n)

  #Get fit stats for correctly specified model
  true_fit <- true_model_fit(model()$datapath,n)

  #Produce final table of fit indices for each level (as a list)
  Table <- purrr::map(misspec_fit,~cbind(.,true_fit))

  #Final table
  return(Table)
})
```

Multi-factor CFA
=====================================  

Row {.tabset}
-----------------------------------------------------------------------


### Instructions

**To generate dynamic fit index cutoffs for multi-factor models:**

1. Input your sample size
1. Write your model statement in a **text** file (.txt).
1. For the  model statement, enter your model's **standardized** factor loadings, factor correlations (if any), and residual correlations (if any).
   - Factor loadings are denoted by = ~
   - Correlations are denoted by ~ ~
   - Enter the magnitude of the relationship first
1. **Important**: Make sure to press enter at the end of the last line of the model statement before saving the text file.  
1. Upload the text file with the model statement and press submit.
1. When the simulations are complete, the results will appear in the **Results** and **Plots** tabs.

<div>
```{r progress1}
#Just added because of a shiny bug with the action button
#Ignore

renderPlot({
  
    shiny::validate(
    shiny::need(modelerror(model()$datapath) != 1,
                "It looks like there might be an error in your model statement. Common errors include: an extra decimal, a missing asterisk, or a missing plus sign. Please inspect your model statement."))
  
    shiny::validate(
    shiny::need(missing_plus(model()$datapath)==0,
                "I think you forgot to include a plus sign in your model statement.  Please inspect your model statement.  This is an experimental error message.  Please email melissagordon@ucsb.edu if you believe this error message is incorrect."))

  shiny::validate(
          shiny::need(tools::file_ext(model()$name) %in% 
                 c('text','.txt','txt'),
               "You must enter a text file (.txt)"))
  
  shiny::validate(
    shiny::need(number_factor(model()$datapath)>1,
                "You entered a one-factor model. Go back to the main page and select the one-factor CFA application."))

  shiny::validate(
    shiny::need(unstandardized(model()$datapath)==0,
    "One of your loadings or correlations has an absolute value of 1 or above (an impossible value). Please use standardized loadings. If all of your loadings are under 1, try looking for a missing decimal somewhere in your model statement."))
  
  shiny::validate(
    shiny::need(defre(model()$datapath,n())>1,
                "It is impossible to add misspecifications to a just identified model."))
  
  shiny::validate(
    shiny::need(nrow(multi_factor_num(model()$datapath))>(number_factor(model()$datapath)-1),
                     "There are not enough free items to produce all misspecification levels."))
  
  invisible(multi_df() %>% 
    unlist())
  
}, width=1,height=1)
```
</div>

**Example:**

<div>
```{r instructions, out.width="65%"}
include_graphics("Example3.png")
```
</div>

**Note**: These cutoff values are currently only accurate for **single level** models using **ML estimation**.  Any cutoff values produced for bi-factor models, higher-order models, or models estimated using WLSMV are inaccurate (you will likely get an error message if you try to compute them).

### Results

These are the dynamic model fit index cutoff values for your model:

<div>
```{r fit-table}
#Generate dynamic model fit index cutoffs and table
renderTable({
  
    shiny::validate(
    shiny::need(modelerror(model()$datapath) != 1,
                "It looks like there might be an error in your model statement. Common errors include: an extra decimal, a missing asterisk, or a missing plus sign. Please inspect your model statement."))
  
    shiny::validate(
    shiny::need(missing_plus(model()$datapath)==0,
                "I think you forgot to include a plus sign in your model statement.  Please inspect your model statement.  This is an experimental error message.  Please email melissagordon@ucsb.edu if you believe this error message is incorrect."))
  
  shiny::validate(
          shiny::need(tools::file_ext(model()$name) %in% 
                 c('text','.txt','txt'),
               "You must enter a text file (.txt)"))
  
  shiny::validate(
    shiny::need(number_factor(model()$datapath)>1,
                "You entered a one-factor model. Go back to the main page and select the one-factor CFA application."))

  shiny::validate(
    shiny::need(unstandardized(model()$datapath)==0,
    "One of your loadings or correlations has an absolute value of 1 or above (an impossible value). Please use standardized loadings. If all of your loadings are under 1, try looking for a missing decimal somewhere in your model statement."))
  
  shiny::validate(
    shiny::need(defre(model()$datapath,n())>1,
                "It is impossible to add misspecifications to a just identified model."))
  
  shiny::validate(
    shiny::need(nrow(multi_factor_num(model()$datapath))>(number_factor(model()$datapath)-1),
                     "There are not enough free items to produce all misspecification levels."))

  #Get the data ready to go
  results <- multi_df()
  
  #For each list element (misspecification) compute the cutoffs
  misspec_sum <- purrr::map(results,~dplyr::summarise(.,SRMR_M=quantile(SRMR_M, c(.05,.1)),
                                        RMSEA_M=quantile(RMSEA_M, c(.05,.1)),
                                        CFI_M=quantile(CFI_M, c(.95,.9))))
  
  #For the true model, compute the cutoffs (these will all be the same - just need in list form)
  true_sum <- purrr::map(results,~dplyr::summarise(.,SRMR_T=quantile(SRMR_T, c(.95,.9)),
                                            RMSEA_T=quantile(RMSEA_T, c(.95,.9)),
                                            CFI_T=quantile(CFI_T, c(.05,.1))))
  
  #Bind each of the misspecified cutoffs to the true cutoffs, listwise
  Table <- purrr::map(misspec_sum,~cbind(.,true_sum[[1]]) %>% 
                 dplyr::mutate(SRMR_R=base::round(SRMR_M,3),
                               RMSEA_R=base::round(RMSEA_M,3),
                               CFI_R=base::round(CFI_M,3),
                               SRMR=base::ifelse(SRMR_T<SRMR_M,SRMR_R,"NONE"),
                               RMSEA=base::ifelse(RMSEA_T<RMSEA_M,RMSEA_R,"NONE"),
                               CFI=base::ifelse(CFI_T>CFI_M,CFI_R,"NONE")) %>%
                 dplyr::select(SRMR,RMSEA,CFI)) 
  
  #This is to clean up the table for presentation
  Row2 <- purrr::map_dfr(Table,~dplyr::mutate(.,SRMR_1=SRMR,
                                RMSEA_1=RMSEA,
                                CFI_1=CFI) %>%
                    dplyr::mutate_at(c("SRMR_1","RMSEA_1","CFI_1"),list(lead)) %>% 
                    dplyr::slice(1) %>% 
                    dplyr::mutate(SRMR=ifelse(is.character(SRMR),SRMR_1,"--"),
                           RMSEA=ifelse(is.character(RMSEA),RMSEA_1,"--"),
                           CFI=ifelse(is.character(CFI),CFI_1,"--"),
                           SRMR=str_replace_all(as.character(SRMR),"0\\.","."),
                           RMSEA=str_replace_all(as.character(RMSEA),"0\\.","."),
                           CFI=str_replace_all(as.character(CFI),"0\\.",".")) %>%
                    dplyr::select(SRMR,RMSEA,CFI)) 
  
  #Still cleaning
  Table_C <- purrr::map_dfr(Table,~dplyr::mutate(.,SRMR=stringr::str_replace_all(as.character(SRMR),"0\\.","."),
                                                 RMSEA=stringr::str_replace_all(as.character(RMSEA),"0\\.","."),
                                                 CFI=stringr::str_replace_all(as.character(CFI),"0\\.",".")))
  
  #Cleaning
  Table_C[seq(2,nrow(Table_C),by=2),] <- Row2 
  
  #For row names
  #Can't use number_factor because some factors may be ineligible for cross-loadings
  #Instead, just grab the length of number of misspecifications we're adding
  num_fact <- length(Misspecified_DGM_Multi(model))
  
  #Create row names for level
  Table_C$levelnum <- paste("Level", rep(1:num_fact,each=2))
  
  #Create row names for proportions
  Table_C$cut <- rep(c("95/5","90/10"))
  
  #Add rownames to final table
  Final_Table <- Table_C %>% 
    tidyr::unite(Cut,levelnum,cut,sep=": ") %>% 
    tibble::column_to_rownames(var='Cut')
  
  },
    digits=3, align='c', rownames = TRUE, width="auto",
    bordered = TRUE) 

```
</div>

\  

**Levels**

Goodness of fit indices can be used *as one piece of evidence of validity* to gauge if your model's misspecifications are trivial or substantial.  You will see a level of misspecification severity for each F-1 factor (where F is the number of factors), in accordance with the procedure established by Hu & Bentler in 1999.  

Hu & Bentler derived their cutoff values from a 3 factor model with 15 items, a range of loadings from .7 - .8, and a range of sample sizes from 250 - 5000.  The cutoff values outputted for **Level 1** are the Hu & Bentler equivalent for *your* particular model.  In other words, if Hu & Bentler had used *your* model to generate cutoff values, these are the cutoff values they would have published.  

Your area(s) of concern may differ from the misspecifications simulated here.  You should also consult the residual correlation matrix for local areas of strain, check out the modification indices, and present other types of evidence of validity (such as an evaluation of participants' response processes).

**Rows**

Within each level, there are two rows.

- The first row of the table represents the ideal cutoff values for that misspecification level.  At this cutoff value, 95% of misspecified models will be correctly rejected, while only 5% of correctly specified models will be incorrectly rejected.  This value is best equipped to distinguish between a well-fitting and misspecified model.

- The second row of the table represents acceptable cutoff values for that misspecification level.  At this cutoff value, 90% of misspecified models will be correctly rejected, while 10% of correctly specified models will be incorrectly rejected.  If the first row says NONE, you should use this value instead.  *This row will be blank if ideal cutoff values are available*.

If you see the word NONE in both rows, that means that there are no dynamic fit index cutoff values for that fit index that will correctly reject a misspecified model 90% of the time while also correctly failing to reject a correctly specified model at least 10% of the time. Thus, this fit index cannot distinguish between well-fitting models and ill-fitting models for your model, for that level of misspecification.

### Plots

A comparison of the fit index distributions for the "true" empirical model and the "misspecified" empirical model, for each level.  The dashed line represents the ideal dynamic model fit cutoff value for the user's empirical model.  The dotted line represents the commonly used cutoff values recommended by Hu & Bentler (1999).

<div>
```{r fit-plot}
#Generate corresponding distributions of fit indices for each model
#This is a reactive, not a render table.  Save it as an object to call later
#Necessary because of lists
plotlist <- reactive({
  
    shiny::validate(
    shiny::need(modelerror(model()$datapath) != 1,
                "It looks like there might be an error in your model statement. Common errors include: an extra decimal, a missing asterisk, or a missing plus sign. Please inspect your model statement."))
  
    shiny::validate(
    shiny::need(missing_plus(model()$datapath)==0,
                "I think you forgot to include a plus sign in your model statement.  Please inspect your model statement.  This is an experimental error message.  Please email melissagordon@ucsb.edu if you believe this error message is incorrect."))

  shiny::validate(
          shiny::need(tools::file_ext(model()$name) %in% 
                 c('text','.txt','txt'),
               "You must enter a text file (.txt)"))
  
  shiny::validate(
    shiny::need(number_factor(model()$datapath)>1,
                "You entered a one-factor model. Go back to the main page and select the one-factor CFA application."))

  shiny::validate(
    shiny::need(unstandardized(model()$datapath)==0,
    "One of your loadings or correlations has an absolute value of 1 or above (an impossible value). Please use standardized loadings. If all of your loadings are under 1, try looking for a missing decimal somewhere in your model statement."))
  
  shiny::validate(
    shiny::need(defre(model()$datapath,n())>1,
                "It is impossible to add misspecifications to a just identified model."))
  
  shiny::validate(
    shiny::need(nrow(multi_factor_num(model()$datapath))>(number_factor(model()$datapath)-1),
                     "There are not enough free items to produce all misspecification levels."))
  
  #Get the data ready to go
  results <- multi_df()
  
  #For each list element (misspecification) compute the cutoffs
  misspec_sum <- purrr::map(results,~dplyr::summarise(.,SRMR_M=quantile(SRMR_M, c(.05,.1)),
                                        RMSEA_M=quantile(RMSEA_M, c(.05,.1)),
                                        CFI_M=quantile(CFI_M, c(.95,.9))))
  
  #For the true model, compute the cutoffs (these will all be the same - just need in list form)
  true_sum <- purrr::map(results,~dplyr::summarise(.,SRMR_T=quantile(SRMR_T, c(.95,.9)),
                                            RMSEA_T=quantile(RMSEA_T, c(.95,.9)),
                                            CFI_T=quantile(CFI_T, c(.05,.1))))
  
  #Select just those variables and rename columns to be the same
  Misspec_dat <- purrr::map(results,~dplyr::select(.,SRMR_M:Type_M) %>% 
                       `colnames<-`(c("SRMR","RMSEA","CFI","Model")))
  
  #Select just those variables and rename columns to be the same
  True_dat <- purrr::map(results,~dplyr::select(.,SRMR_T:Type_T) %>% 
                    `colnames<-`(c("SRMR","RMSEA","CFI","Model")))
  
  #For each element in the list, bind the misspecified cutoffs to the true cutoffs
  #rbind doesn't work well with lists (needs do.call statement)
  plot <- lapply(seq(length(Misspec_dat)),function(x) dplyr::bind_rows(Misspec_dat[x],True_dat[x]))
  
  #Plot SRMR. Need map2 and data=.x (can't remember why).
  SRMR_plot <- purrr::map2(plot,misspec_sum,~ggplot(data=.x,aes(x=SRMR,fill=Model))+
                      geom_histogram(position="identity",
                                     alpha=.5, bins=30)+
                      scale_fill_manual(values=c("#E9798C","#66C2F5"))+
                      geom_vline(aes(xintercept=.y$SRMR_M[1],
                                     linetype="misspec_sum$SRMR_M[1]",color="misspec_sum$SRMR_M[1]"),
                                 size=.6)+
                      geom_vline(aes(xintercept=.08,
                                     linetype=".08",color=".08"),
                                 size=.75)+
                      scale_color_manual(name="Cutoff Values",
                                         labels=c("Dynamic Cutoff","Hu & Benter Cutoff"),
                                         values=c("misspec_sum$SRMR_M[1]"="black",
                                                  ".08"="black"))+
                      scale_linetype_manual(name="Cutoff Values",
                                            labels=c("Dynamic Cutoff","Hu & Benter Cutoff"),
                                            values=c("misspec_sum$SRMR_M[1]"="longdash",
                                                     ".08"="dotted"))+
                      theme(axis.title.y = element_blank(),
                            axis.text.y = element_blank(),
                            axis.ticks.y = element_blank(),
                            panel.background = element_blank(),
                            axis.line = element_line(color="black"),
                            legend.position = "none",
                            legend.title = element_blank(),
                            legend.box = "vertical"))
  
  #Plot RMSEA.  Need map2 and data=.x (can't remember why).
  RMSEA_plot <- purrr::map2(plot,misspec_sum,~ggplot(data=.x,aes(x=RMSEA,fill=Model))+
                       geom_histogram(position="identity",
                                      alpha=.5, bins=30)+
                       scale_fill_manual(values=c("#E9798C","#66C2F5"))+
                       geom_vline(aes(xintercept=.y$RMSEA_M[1],
                                      linetype="misspec_sum$RMSEA_M[1]",color="misspec_sum$RMSEA_M[1]"),
                                  size=.6)+
                       geom_vline(aes(xintercept=.06,
                                      linetype=".06",color=".06"),
                                  size=.75)+
                       scale_color_manual(name="Cutoff Values",
                                          labels=c("Dynamic Cutoff","Hu & Benter Cutoff"),
                                          values=c("misspec_sum$RMSEA_M[1]"="black",
                                                   ".06"="black"))+
                       scale_linetype_manual(name="Cutoff Values",
                                             labels=c("Dynamic Cutoff","Hu & Benter Cutoff"),
                                             values=c("misspec_sum$RMSEA_M[1]"="longdash",
                                                      ".06"="dotted"))+
                       theme(axis.title.y = element_blank(),
                             axis.text.y = element_blank(),
                             axis.ticks.y = element_blank(),
                             panel.background = element_blank(),
                             axis.line = element_line(color="black"),
                             legend.position = "none",
                             legend.title = element_blank(),
                             legend.box = "vertical"))
  
  #Plot CFI. Need map2 and data=.x (can't remember why).
  CFI_plot <- purrr::map2(plot,misspec_sum,~ggplot(data=.x,aes(x=CFI,fill=Model))+
                     geom_histogram(position="identity",
                                    alpha=.5, bins=30)+
                     scale_fill_manual(values=c("#E9798C","#66C2F5"))+
                     geom_vline(aes(xintercept=.y$CFI_M[1],
                                    linetype="misspec_sum$CFI_M[1]",color="misspec_sum$CFI_M[1]"),
                                size=.6)+
                     geom_vline(aes(xintercept=.95,
                                    linetype=".95",color=".95"),
                                size=.75)+
                     scale_color_manual(name="Cutoff Values",
                                        labels=c("Dynamic Cutoff","Hu & Benter Cutoff"),
                                        values=c("misspec_sum$CFI_M[1]"="black",
                                                 ".95"="black"))+
                     scale_linetype_manual(name="Cutoff Values",
                                           labels=c("Dynamic Cutoff","Hu & Benter Cutoff"),
                                           values=c("misspec_sum$CFI_M[1]"="longdash",
                                                    ".95"="dotted"))+
                     theme(axis.title.y = element_blank(),
                           axis.text.y = element_blank(),
                           axis.ticks.y = element_blank(),
                           panel.background = element_blank(),
                           axis.line = element_line(color="black"),
                           legend.position = "none",
                           legend.title = element_blank(),
                           legend.box = "vertical"))
  
  
  #Create a list with the plots combined for each severity level
  plots_combo <- lapply(seq(length(plot)),function(x) c(SRMR_plot[x],RMSEA_plot[x],CFI_plot[x]))
  
  #Add a collective legend and title with the level indicator
  plots <- lapply(seq(length(plots_combo)), function(x) wrap_plots(plots_combo[[x]])+
           plot_layout(guides = "collect")+
           plot_annotation(title=paste("Level", x))
         & theme(legend.position = 'bottom'))
  
  plots
  
})

#https://stackoverflow.com/questions/36799901/r-markdown-shiny-renderplot-list-of-plots-from-lapply

renderUI({
    plot_output_list <- lapply(1:length(plotlist()), function(i) {
        plotname <- paste("plot", i, sep="")
        plotOutput(plotname)
    })
    do.call(tagList, plot_output_list)
})

observe({
for (i in 1:length(plotlist())) {
    local({
        my_i <- i
        plotname <- paste("plot", my_i, sep="")
        output[[plotname]] <- renderPlot({
            plotlist()[[my_i]]
        }, width=900,height = 325)
    })
}
})

```
</div>

### Info

These are the misspecification(s) that were added to your data generating model.  These misspecifications are additive across levels.  In other words, a level 2 misspecification has the misspecification from level 1 in addition to the misspecification from level 2.  In total, there are F-1 misspecifications, where F is the number of factors in the model. This is a replication of the approach used by Hu & Bentler (1999), applied to the user's model.

```{r}
renderTable({
  
    shiny::validate(
    shiny::need(modelerror(model()$datapath) != 1,
                "It looks like there might be an error in your model statement. Common errors include: an extra decimal, a missing asterisk, or a missing plus sign. Please inspect your model statement."))
  
    shiny::validate(
    shiny::need(missing_plus(model()$datapath)==0,
                "I think you forgot to include a plus sign in your model statement.  Please inspect your model statement.  This is an experimental error message.  Please email melissagordon@ucsb.edu if you believe this error message is incorrect."))
  
  shiny::validate(
          shiny::need(tools::file_ext(model()$name) %in% 
                 c('text','.txt','txt'),
               "You must enter a text file (.txt)"))
  
  shiny::validate(
    shiny::need(number_factor(model()$datapath)>1,
                "You entered a one-factor model. Go back to the main page and select the one-factor CFA application."))

  shiny::validate(
    shiny::need(unstandardized(model()$datapath)==0,
    "One of your loadings or correlations has an absolute value of 1 or above (an impossible value). Please use standardized loadings. If all of your loadings are under 1, try looking for a missing decimal somewhere in your model statement."))
  
  shiny::validate(
    shiny::need(defre(model()$datapath,n())>1,
                "It is impossible to add misspecifications to a just identified model."))
  
  shiny::validate(
    shiny::need(nrow(multi_factor_num(model()$datapath))>(number_factor(model()$datapath)-1),
                     "There are not enough free items to produce all misspecification levels."))
  
  #Return crossloadings that were added
  m_info <- multi_factor(model()$datapath)
  
  #Just simple formatting
  add <- m_info %>% 
    tidyr::separate(V1, into=c("a","b","c","d","e"), sep=" ") %>% 
    dplyr::select(c) %>% 
    dplyr::mutate("Magnitude of Omitted Loading"=stringr::str_replace_all(c,"0\\.","."),
                  "Additional Paths in DGM"=dplyr::row_number(),
                  "Level"=paste("Level",row_number())) %>% 
    dplyr::select("Level","Additional Paths in DGM","Magnitude of Omitted Loading") %>% 
    tibble::remove_rownames() %>% 
    tibble::column_to_rownames(var="Level")
  
  add
},
    digits=3, align='c', rownames = TRUE, width="auto",
    bordered = TRUE)
```


### References

To cite the ideas behind dynamic model fit index cutoff values:

- [McNeish, D.](https://sites.google.com/site/danielmmcneish/home){target="_parent"} & [Wolf, M. G.](https://www.melissagwolf.com/){target="_parent"} (2021). Dynamic Fit Index Cutoffs for Confirmatory Factor Analysis Models.
*Psychological Methods*. [https://doi.org/10.1037/met0000425](https://psycnet.apa.org/record/2021-98816-001){target="_parent"}

    - [*PsyArXiv link*](https://psyarxiv.com/v8yru/){target="_parent"}

To cite the dynamic model index cutoff values generated by this app:

- [Wolf, M. G.](https://www.melissagwolf.com/){target="_parent"} & [McNeish, D.](https://sites.google.com/site/danielmmcneish/home){target="_parent"} (2020). Dynamic Model Fit. R Shiny application version 1.1.0.

    - [*R Package (beta)*](https://github.com/melissagwolf/dynamic){target="_parent"}
    
<span style="color: #93002D;">Please submit bug reports to [Melissa Wolf](mailto:melissagordon@ucsb.edu).</span>

\  

Computationally, this app relies on the following packages:

- [lavaan](http://www.jstatsoft.org/v48/i02/){target="_parent"}. Rosseel, Y. (2012). lavaan: An R Package for Structural Equation Modeling. Journal of Statistical Software, 48(2), 1-36.
- [simstandard](https://CRAN.R-project.org/package=simstandard){target="_parent"}. Schneider, W. J. (2019). simstandard: Generate Standardized Data. R package version 0.3.0. 
- [tidyverse](https://doi.org/10.21105/joss.01686){target="_parent"}. Wickham et al., (2019). Welcome to the tidyverse. Journal of Open Source Software, 4(43), 1686.

Aesthetically, this app relies on the following packages:

- [shiny](https://CRAN.R-project.org/package=shiny){target="_parent"}. Chang, W., Cheng, J., Allaire, J., Xie, Y., & McPherson, J. (2020). shiny: Web Application Framework for R. R package version 1.4.0.2.
- [flexdashboard](https://CRAN.R-project.org/package=flexdashboard){target="_parent"}. Iannone, R., Allaire, J., & Borges, B. (2018). flexdashboard: R
  Markdown Format for Flexible Dashboards. R package version 0.5.1.1.
- [shinythemes](https://CRAN.R-project.org/package=shinythemes){target="_parent"}. Winston Chang (2018). shinythemes: Themes for Shiny. R package version 1.1.2.
- [shinybusy](https://CRAN.R-project.org/package=shinybusy){target="_parent"}. Meyer, F. & Perrier, V. (2019). shinybusy: Busy Indicator for 'Shiny' Applications. R package version 0.2.0. 
- [patchwork](https://CRAN.R-project.org/package=patchwork){target="_parent"}. Pendersen, T. L. (2020). patchwork: The Composer of Plots. R package version 1.0.1.
- [knitr](https://yihui.org/knitr/){target="_parent"}. Xie, Y. (2020). knitr: A General-Purpose Package for Dynamic Report Generation in R. R package version 1.28.

This app began as a project in a graduate course taught by [Allison Horst](https://www.allisonhorst.com/){target="_parent"}.

<div>
```{r progress2}
#Just added because of a shiny bug with the action button
#Ignore

renderPlot({
  
    shiny::validate(
    shiny::need(modelerror(model()$datapath) != 1,
                "It looks like there might be an error in your model statement. Common errors include: an extra decimal, a missing asterisk, or a missing plus sign. Please inspect your model statement."))
  
    shiny::validate(
    shiny::need(missing_plus(model()$datapath)==0,
                "I think you forgot to include a plus sign in your model statement.  Please inspect your model statement.  This is an experimental error message.  Please email melissagordon@ucsb.edu if you believe this error message is incorrect."))
  
  shiny::validate(
          shiny::need(tools::file_ext(model()$name) %in% 
                 c('text','.txt','txt'),
               "You must enter a text file (.txt)"))
  
  shiny::validate(
    shiny::need(number_factor(model()$datapath)>1,
                "You entered a one-factor model. Go back to the main page and select the one-factor CFA application."))

  shiny::validate(
    shiny::need(unstandardized(model()$datapath)==0,
    "One of your loadings or correlations has an absolute value of 1 or above (an impossible value). Please use standardized loadings. If all of your loadings are under 1, try looking for a missing decimal somewhere in your model statement."))
  
  shiny::validate(
    shiny::need(defre(model()$datapath,n())>1,
                "It is impossible to add misspecifications to a just identified model."))
  
  shiny::validate(
    shiny::need(nrow(multi_factor_num(model()$datapath))>(number_factor(model()$datapath)-1),
                     "There are not enough free items to produce all misspecification levels."))
  
  invisible(multi_df() %>% 
    unlist())
  
}, width=1,height=1)
```
</div>
